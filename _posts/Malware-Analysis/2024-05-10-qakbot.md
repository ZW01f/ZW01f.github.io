---
title: "Qakbot v5"
classes: wide
header:
  teaser: /assets/images/malware-analysis/qakbot/thumbnail.png
ribbon: DodgerBlue
description: "Dissecting qakbot the famous malware loader. qakbot is currently in the wild sneaking into organizations using phishing campaign ..."
categories:
  - Malware Analysis
toc: true
---
# Meet Qakbot 

QakBot, also recognized as QBot, QuackBot, and Pinkslipbot, has been operational for years, initially as a financial malware targeting governments and businesses for financial fraud by pilfering user credentials and keystrokes . 
Over time, it has evolved into a malware dropper, spreading sensitive information to other network systems. 
The threat group has recently updated their codebase to support 64-bit versions of Windows, enhanced encryption algorithms, and added further obfuscation techniques.
With the release of Qakbot version 5.0, the string encryption algorithm underwent a significant change. While strings are still encrypted using a simple XOR key, the key is no longer hardcoded in the data section. Instead, it is encrypted with AES.

# Technical in Points

1. Qakbot uses API hashing to hide its imports. It uses CRC32 hashing, along with another layer of XORing with a hard-coded key. It’s prasing the loaded DLLs in memory and getting its export tables. As a result, qakbot can resolve imported  APIs and build its IAT.
2. Qakbot comes with encrypted strings inside the .data section , These strings encrypted using a xor key and that key is encrypted using AES algorithm . 

3. Qakbot will gather information about the compromised host in order to send its c2 server as well as to generate a unique victim fingerprinting. Collected information contains OS version, Domains trusts, Computer name & username, screen resolution, system time, system uptime, and bot uptime ...

# Basic Info (can make it IOC and put on the conclusion)

| SHA-256                 | af6a9b7e7aefeb903c76417ed2b8399b73657440ad5f8b48a25cfe5e97ff868f |
|-------------------------|-----------------------------------------------------------------|
| File type               | Win DLL                                                         |
| Target Machine          | x64                                                          |
| Creation Time           | 2024-01-29 13:43:37 UTC                                        |
| First Seen In The Wild  | 2024-02-07 10:12:50 UTC                                        |

[![](/assets/images/malware-analysis/qakbot/virus_total.png)](/assets/images/malware-analysis/qakbot/virus_total.png)
<center><font size="3"><u>Figure</u>(1): <u>sample on VirusTotal</u></font> </center> 
<br>

# Anti Analysis
## API Resolution

QakBot uses Windows API Hashing (Dynamic API Resolution) to evade signature-based anti-malware scanners and make static analysis harder.

[![](/assets/images/malware-analysis/qakbot/api_hash_1.png)](/assets/images/malware-analysis/qakbot/api_hash_1.png)
<center><font size="3"><u>Figure</u>(2): <u>API hashes</u></font> </center> 
<br>
We can see based on algorithm constants that qakbot using the CRC32 hash algorithm, also there is another layer of XORing, and here are the steps in some detail :

The DllName is decrypted by XORing with a hard-coded key 0xA235CB91. After decryption, a handle to the DLL is obtained. This handle is then passed to a function that iterates over the DLL's exported functions. 
A function resolves the addresses of the exports by iterating over the export table of the module, hashing the name of each export using CRC32, and comparing the result with a hard-coded CRC32 hash to determine if it has found the correct address  . 

[![](/assets/images/malware-analysis/qakbot/api_res_process.png)](/assets/images/malware-analysis/qakbot/api_res_process.png)
<center><font size="3"><u>Figure</u>(3): <u>API resolving Steps</u></font> </center> 
<br>
With knowledge of the algorithm name and XOR key , we can use  the awesome [hashdb](https://github.com/OALabs/hashdb-ida)
 plugin from OALabs that performs string hash lookup against a remote database  

<p align="center">
  <a href="/assets/images/malware-analysis/qakbot/hashdb_res.png">
    <img src="/assets/images/malware-analysis/qakbot/hashdb_res.png" alt="API Response Process">
  </a>
</p>
<center><font size="3"><u>Figure</u>(3): <u>hashdb result</u></font> </center> 
<br>

Once the HashDB plugin decrypts all API names, we create structures to  store the API lists from each DLL. This simplifies our workflow and make our life easier while analysis .

<p align="center">
  <a href="/assets/images/malware-analysis/qakbot/dec_iat.png">
    <img src="/assets/images/malware-analysis/qakbot/dec_iat.png" alt="API Response Process">
  </a>
</p>
<center><font size="3"><u>Figure</u>(3): <u>populated IAT</u></font> </center> 
<br>

## String decrpytion 
qakbot strings are obfuscated , making the analysis more difficult , so the next step is to decrypt them 

**Decryption routine**

This version decrypts the strings with an xor key just like the earlier versions but this xor key is encrypted using the AES algorithm. 

[![](/assets/images/malware-analysis/qakbot/str_dec_0.png)](/assets/images/malware-analysis/qakbot/str_dec_0.png)

it first Calculates a SHA256 hash for aes_key_ref and uses the calculated hash as the AES Key then decrypt the enc_xor_key blob using AES in CBC mode to have the dec_xor_key.

[![](/assets/images/malware-analysis/qakbot/str_dec_1.png)](/assets/images/malware-analysis/qakbot/str_dec_1.png)
<center><font size="3"><u>Figure</u>(3): <u>The xor key decryption process </u></font> </center> 

The final step is to use the dec_xor_key to decrypt the string array.

[![](/assets/images/malware-analysis/qakbot/str_dec_2.png)](/assets/images/malware-analysis/qakbot/str_dec_2.png)
<center><font size="3"><u>Figure</u>(3): <u>String decryption process</u></font> </center> 

**Writing a decryption script**

We now can write an IDAPython script to decrypt the strings and add comments to the code, making analysis easier and here are some notes before the script : 
- The first 16 bytes of the enc_xor_key are used as the AES IV . 
- There are two encrypted strings table used .
- There are two decryption functions with 4 wraps . 
- The wrap function decrypts the string array and selects the string based on an index [the only argument]. 

<p align="center">
  <img src="/assets/images/malware-analysis/qakbot/pattern_1.png" width="45%" />
  <img src="/assets/images/malware-analysis/qakbot/pattern_2.png" width="45%" />
</p>
<p align="center"><font size="3"><u>Figure</u>(3): <u>index pattern</u></font></p>

```python
#--------------- imports --------------------#
import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import idautils
#------------- helper ------------------------#
def hex_to_int(x):
    if type(x) == int :
        return x 
    return (int(x[:-1], 16))
def search_by_index(table , ind):
    return(table[ind:].split('\x00')[0])
#------------- IDA py ------------------------#
def read_data_ida(address,size):
  data = idc.get_bytes(address, size)
  return data
def set_comment(address, text):
    idc.set_cmt(address, text,0)
#------------ Decryption ---------------------#
def calculate_sha256(input_data):
    sha256_hash = hashlib.sha256()
    sha256_hash.update(input_data)
    hash_hex = sha256_hash.digest()
    return hash_hex
def aes_decrypt(ciphertext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    unpadded_plaintext = unpad(plaintext, AES.block_size)
    return unpadded_plaintext
def xor_decrypt(data,key):
  dec_data = ''
  for i in range(len(data)):
      dec_data += chr(data[i] ^ key[i % len(key)])
  return dec_data
def full_dec(enc_str , enc_xor_key , aes_key_init):
    aes_key = calculate_sha256(aes_key_init)
    dec_xor_key = aes_decrypt(enc_xor_key[16:],aes_key,enc_xor_key[:16])
    dec_str = xor_decrypt(enc_str,dec_xor_key)
    return dec_str
#----------- Decrypt enc str tbl 1 -------------#
enc_str_1 , enc_xor_key_1 , aes_key_init_1 = read_data_ida(0x1800297A0 , 0x1836) , read_data_ida(0x18002AFE0,0xA0) , read_data_ida(0x180029700,0x9F) #read our data . 
tbl_1 = full_dec(enc_str_1,enc_xor_key_1,aes_key_init_1)
#----------- Decrypt enc str tbl 2 -------------#
enc_str_2 , enc_xor_key_2 , aes_key_init_2 = read_data_ida(0x1800282A0 , 0x5AD) , read_data_ida(0x1800281C0,0xD0) , read_data_ida(0x180028150,0x63) #read our data . 
tbl_2 = full_dec(enc_str_2,enc_xor_key_2,aes_key_init_2)

#--> pattern used: mov ecx , immediate_val
def do_magic(table,references):
    for ref in references:
        prev_instruction_address = idc.prev_head(ref)   
        if (idc.print_insn_mnem(prev_instruction_address) == 'mov' and idc.print_operand(prev_instruction_address,0) == 'ecx' and idc.get_operand_type(prev_instruction_address,1) == 5):
            ind = print_operand(prev_instruction_address,1)
            set_comment(ref,search_by_index(table,hex_to_int(ind)))
        else : 
            prev_instruction_address = idc.prev_head(prev_instruction_address)
            if (idc.print_insn_mnem(prev_instruction_address) == 'mov' and idc.print_operand(prev_instruction_address,0) == 'ecx' and idc.get_operand_type(prev_instruction_address,1) == 5):
                ind = print_operand(prev_instruction_address,1)
                set_comment(ref,search_by_index(table,hex_to_int(ind)))
            else:
                prev_instruction_address = idc.prev_head(prev_instruction_address)
                if (idc.print_insn_mnem(prev_instruction_address) == 'mov' and idc.print_operand(prev_instruction_address,0) == 'ecx' and idc.get_operand_type(prev_instruction_address,1) == 5):
                    ind = print_operand(prev_instruction_address,1)
                    set_comment(ref,search_by_index(table,hex_to_int(ind)))
                else:
                    print('not working' ,hex(ref))

reference_1 = list(idautils.CodeRefsTo(idc.get_name_ea_simple("wrap_mw_decrpyion_fun_1"), 0)) #codeRefs-to need "ea" as arguemt . 
reference_1 = reference_1 + list(idautils.CodeRefsTo(idc.get_name_ea_simple('wrap_2_mw_decrpyion_fun_1') , 0))

reference_2 = list(idautils.CodeRefsTo(idc.get_name_ea_simple('wrap_2_mw_decrpyion_fun_2'), 0))
reference_2 = reference_2 + list(idautils.CodeRefsTo(idc.get_name_ea_simple('wrap_mw_decrpyion_fun_2'), 0))
def main():
    do_magic(tbl_1,reference_1)
    do_magic(tbl_2,reference_2)

if __name__ == '__main__':
    main()
```

<p align="center">
  <a href="/assets/images/malware-analysis/qakbot/script_res.png">
    <img src="/assets/images/malware-analysis/qakbot/script_res.png" alt="API Response Process">
  </a>
</p>
<center><font size="3"><u>Figure</u>(3): <u>IDA python script result</u></font> </center> 
<br>

**The full decrypted string list**

<details>
<summary>Click to expand</summary>

<ul>

<li>%SystemRoot%\SysWOW64\xwizard.exe </li>
<li>kernelbase.dll</li>
<li>WBJ_IGNORE</li>
<li>mpr.dll</li>
<li>%SystemRoot%\explorer.exe</li>
<li>%SystemRoot%\System32\CertEnrollCtrl.exe</li>
<li>https</li>
<li>SentinelServiceHost.exe;SentinelStaticEngine.exe;SentinelAgent.exe;SentinelStaticEngineScanner.exe;SentinelUI.exe</li>
<li>open</li>
<li>root\SecurityCenter2</li>
<li>%SystemRoot%\SysWOW64\SndVol.exe</li>
<li>%u.%u.%u.%u.%u.%u.%04x</li>
<li>1234567890</li>
<li>%SystemRoot%\System32\Utilman.exe</li>
<li>snxhk_border_mywnd</li>
<li>%SystemRoot%\SysWOW64\wextract.exe</li>
<li>avgcsrvx.exe;avgsvcx.exe;avgcsrva.exe</li>
<li>Win32_PhysicalMemory</li>
<li>Caption</li>
<li>ByteFence.exe</li>
<li>aswhooka.dll</li>
<li>dwengine.exe;dwarkdaemon.exe;dwwatcher.exe</li>
<li>%SystemRoot%\SysWOW64\grpconv.exe</li>
<li>VRTUAL;VMware;VMW;Xen</li>
<li>SELECT * FROM AntiVirusProduct</li>
<li>%s\\%08X.dll</li>
<li>wininet.dll</li>
<li>avp.exe;kavtray.exe</li>
<li>rundll32.exe </li>
<li>Create</li>
<li>WQL</li>
<li>%SystemRoot%\System32\sethc.exe</li>
<li>AvastSvc.exe;aswEngSrv.exe;aswToolsSvc.exe;afwServ.exe;aswidsagent.exe;AvastUI.exe</li>
<li>Software\Classes</li>
<li>vkise.exe;isesrv.exe;cmdagent.exe</li>
<li>LastBootUpTime</li>
<li>MS_VM_CERT;VMware;Virtual Machine</li>
<li>Winsta0</li>
<li>.dll</li>
<li>Caption,Description,DeviceID,Manufacturer,Name,PNPDeviceID,Service,Status</li>
<li>SonicWallClientProtectionService.exe;SWDash.exe</li>
<li>t=%s time=[%02d:%02d:%02d-%02d/%02d/%d]</li>
<li>SystemRoot</li>
<li>CommandLine</li>
<li>%SystemRoot%\SysWOW64\explorer.exe</li>
<li>SOFTWARE\Wow6432Node\Microsoft AntiMalware\SpyNet</li>
<li>%s\system32\\</li>
<li>SELECT * FROM Win32_OperatingSystem</li>
<li>wbj.go</li>
<li>System32</li>
<li>CynetEPS.exe;CynetMS.exe;CynetConsole.exe</li>
<li>C:\INTERNAL\__empty</li>
<li>cmd.exe</li>
<li>SOFTWARE\Microsoft\Windows\CurrentVersion\Run</li>
<li>*/*</li>
<li>MsMpEng.exe</li>
<li>image/pjpeg</li>

</ul>
</details>


## Emulation Check
Qbot uses the **GetFileAttributesW** function to check for a folder  <u> "C:\INTERNAL__empty."</u> 
If this directory exists, it suggests that the environment might be used for analysis, such as Microsoft Defender emulation or sandbox, and then the process will terminate.

[![](/assets/images/malware-analysis/qakbot/anti_sandbox.png)](/assets/images/malware-analysis/qakbot/anti_sandbox.png)
<center><font size="3"><u>Figure</u>(3): <u>anti emulation 1</u></font> </center> 


## Checking Processes

Qakbot loops through running processes on the system and compares their executable names against well-known static and dynamic malware analysis tools .  

[![](/assets/images/malware-analysis/qakbot/anti_analysis_1.png)](/assets/images/malware-analysis/qakbot/anti_analysis_1.png)
<center><font size="3"><u>Figure</u>(3): <u>qakbot search for tool's process</u></font> </center> 

**full processes list**
<details style="color: #EEFFFF; font-family: monospace !default; font-size: 0.85em; background: #263238; border: 1px solid #263238; border-radius: 3px; padding: 10px; line-height: 1.8">
    <summary style="outline: none; cursor: pointer">
        <span style="color: darkgray">
            Expand to see more
        </span><br>
        &emsp; wireshark.exe<br>
        &emsp; filemon.exe<br>
        &emsp; procmon.exe<br>
        &emsp; idaq64.exe<br>
        &emsp; tcpview.exe<br>
    </summary>
    &emsp; frida-winjector-helper-32.exe<br>
    &emsp; frida-winjector-helper-64.exe<br>
    &emsp; tcpdump.exe<br>
    &emsp; windump.exe<br>
    &emsp; ethereal.exe<br>   
    &emsp; ettercap.exe<br>
    &emsp; rtsniff.exe<br>
    &emsp; packetcapture.exe<br>
    &emsp; capturenet.exe<br>
    &emsp; qak_proxy<br>
    &emsp; dumpcap.exe<br>
    &emsp; CFF Explorer.exe<br>
    &emsp; not_rundll32.exe<br>
    &emsp; ProcessHacker.exe<br>
    &emsp; loaddll32.exe<br>
    &emsp; PETools.exe<br>
    &emsp; ImportREC.exe<br>
    &emsp; LordPE.exe<br>
    &emsp; SysInspector.exe<br>
    &emsp; proc_analyzer.exe<br>
    &emsp; sysAnalyzer.exe<br>
    &emsp; sniff_hit.exe<br>
    &emsp; joeboxcontrol.exe<br>
    &emsp; joeboxserver.exe<br>
    &emsp; ResourceHacker.exe<br>
    &emsp; x64dbg.exe<br>
    &emsp; Fiddler.exe<br>
    &emsp; sniff_hit.exe<br>
    &emsp; sysAnalyzer.exe<br>
    &emsp; BehaviorDumper.exe<br>
    &emsp; processdumperx64.exe<br>
    &emsp; anti-virus.EXE<br>
    &emsp; sysinfoX64.exe<br>
    &emsp; sctoolswrapper.exe<br>
    &emsp; sysinfoX64.exe<br>
    &emsp; FakeExplorer.exe<br>
    &emsp; apimonitor-x86.exe<br>
    &emsp; idaq.exe<br>
    &emsp; dumper64.exe<br>
    &emsp; user_imitator.exe<br>
    &emsp; Velociraptor.exe<br>
</details>

## Anti VM
Qakbot exploits Windows Management Instrumentation (WMI), a system management technology used to administer remote systems and provide comprehensive data about the operating system, hardware, and installed software and applications on a computer. 

- It use WMI queries to gather system information, including details about virtualization. It queries classes such as **Win32_ComputerSystem**, **Win32_Bios**, **Win32_DiskDrive**, or **Win32_PhysicalMemory**, then check for patterns indicative of virtualized environments. These patterns include known manufacturer or model strings associated with virtualization platforms. 

Below are the classes and their corresponding checked values : 

| Class                | Checked Values                                                |
|----------------------|---------------------------------------------------------------|
| Win32_ComputerSystem | MS_VM_CERT, VMware, Virtual Machine                           |
| Win32_Bios           | VRTUAL, VMware, VMW, Xen                                      |
| Win32_DiskDrive      | VMware, PROD_VIRTUAL_DISK, VIRTUAL-DISK, XENSRC, 20202020     |
| Win32_PhysicalMemory | VMware, VMW, QEMU                                             |
| Win32_PnPEntity      | QEMU, VMware Pointing, VMware Accelerated, VMware SCSI,..     |

<br>
Qakbot also searches for 'vmnat', a process initiated by VMware upon startup. 'vmnat' manages communication in the Network Address Translation (NAT) setup with the guest machine 

# Config Extractor

[![](/assets/images/malware-analysis/qakbot/enc_campaign.png)](/assets/images/malware-analysis/qakbot/enc_campaign.png)
<center><font size="3"><u>Figure</u>(1): <u>How qakbot can sneak into your environment to download additional malwares.</u></font> </center> 
<br>
qakbot DLL is embedded within malicious documents delivered by phishing e-mails . The method that the malicious document uses to achieve execution is usually a VBA macro that is executed when the document is opened. Being dropped by the doc file, the initial packed DLL is an intermediate stage responsible for unpacking and exposing the true functionality of qakbot. Based on the collected information about the victim host, it will decide which malware to deploy. qakbot will then proceed to perform the loading functionality in order to infect the system with the actual malicious content.



[![](/assets/images/malware-analysis/qakbot/unique_ID.png)](/assets/images/malware-analysis/qakbot/unique_ID.png)
<center><font size="3"> <u>Figure</u>(5): <u>The malware uses</u> GetAdaptersAddresses <u>to obtain the required info.</u></font> </center>
<br>
It creates a unique ID for the victim using its MAC addresses of all the connected adapters XORed with the Windows directory volume serial number.

[![](/assets/images/malware-analysis/qakbot/concatinating_profile.png)](/assets/images/malware-analysis/qakbot/concatinating_profile.png)
<center><font size="3"> <u>Figure(</u>6): check_if_x64 <u>routine is used to determine if the victim machine is x64 or not.</u> </font></center> 
<br>
Then, it concatenates the final string which will hold the collected host information to be sent to the C&C server. The call to `mw_wrap_config_decryption` routine will be discussed in details in a few lines. It's used to extract the embedded configuration which will also be used in the final host profile. Something that can be very useful while  **YARA rules** is the format string `{"GUID=%I64u&BUILD=%s&INFO=%s&EXT=%s&IP=%s&TYPE=1&WIN=%d.%d"}` which makes a good *indicator* for qakbot . These collected characteristics about the infected host will decide which malware will be deployed. For instance, if the host is connected to an active directory domain, **Cobalt Strike** malware will be downloaded and executed.



## Configuration Extraction

[![](/assets/images/malware-analysis/qakbot/enc_config_dump.png)](/assets/images/malware-analysis/qakbot/enc_config_dump.png)
<center> <font size="3"><u>Figure</u>(7): <u>Hexadecimal representation of the data residing at the .data section.</u> </font></center> 
<br>
But before finishing the host profile, the malware decrypts the embedded configuration in order to send a copy to the C&C server. The decryption routine references two global data variables very close the beginning of the .*data section*. From the way the parameters are arranged for the decryption routine, I've concluded that the 8 bytes beginning at `0x5A5010` are the decryption key followed by the encrypted configuration.  

[![](/assets/images/malware-analysis/qakbot/config_decryption.png)](/assets/images/malware-analysis/qakbot/config_decryption.png)
<center><font size="3"> <u>Figure</u>(8): <u>You can use the MSDN documentation for more information about the APIs.</u></font> </center> 
<br>
qakbot comes with embedded **RC4** encrypted configuration with hard-coded key. It uses the Microsoft Windows `CryptoAPI`to do the decryption. First, the key will be **SHA-1** hashed before attempting the decryption. Then only the **first 5 bytes** of the hashed key will be used to decrypt the encrypted data.

The upper 16 bits of the 4th parameter denotes the size of the RC4 decryption key. Here it's `0x280011 = 0000000000101000 -- 0000000000010001` 
in which `101000 = 40 bits or 5 bytes`.

[![](/assets/images/malware-analysis/qakbot/cyberchef_data.png)](/assets/images/malware-analysis/qakbot/cyberchef_data.png)
<center><font size="3"> <u>Figure</u>(9): <u>Screen-shot from the actual decrypted configuration the malware uses.</u></font> </center>
<br>
We can use [CyberChef](https://gchq.github.io/CyberChef/) to simulate the decryption process statically. First, the 8 bytes key `{f0da08fe225d0a8f}` will be `SHA-1 hashed = {67f6c6259f8f4ef06797bbd25edc128fd64e6ad7}`. Then, the first 5 bytes of the key will be used as the final RC4 decryption key for decrypting the configuration data. These configuration contains the C2 which it will communicate with for further commands based on the collected host profile. Here at the bottom right corner, we can see that the malware comes with 3 C&C servers to try to connect with. At the end of this report, we will use another way to automatically extract the embedded configuration using Python. 



# Gather system INFO

Part of QakBOT communication with its command and control is sending information about the computer.
QakBot gathers computer information using a combination of Windows API calls, shell commands, and Windows Management Instrumentation (WMI) commands. This approach allows it to collect various details about the system, including hardware, software, and configuration data. By using these methods together, QakBot obtains a comprehensive overview of the target computer's setup and specifications.

### VMI Queries Used
qakbot builds a WMI query by concatenating strings to form It then executes these queries to retrieve critical data and  obtain a comprehensive overview of the system's configuration and installed security measures .

[![](/assets/images/malware-analysis/qakbot/vmi_query.png)](/assets/images/malware-analysis/qakbot/vmi_query.png)
<center> <font size="3"><u>Figure</u>(15): %TEMP% <u>directory is used to store ephemeral temporary files.</u></font> </center>
<br>

Here are the WMI classes targeted and the information they retrieve:

| Class                 | Properties                                                                                               | Result                                                                                                                |
|-----------------------|----------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Win32_OperatingSystem | Caption                                                                                                  | OS Info [name and version]                                                                                            |
| AntiVirusProduct      | *                                                                                                        | Information about antivirus products installed on a system                                                           |
| Win32_Processor       | *                                                                                                        | Information about the processor                                                                                       |
| Win32_ComputerSystem  | *                                                                                                        | Information about the computer system, including its hardware configuration, such as the manufacturer, model, system type, number of processors, memory |
| Win32_Bios            | *                                                                                                        | Details about a computer's BIOS, like its version, manufacturer, and release date                                   |
| Win32_DiskDrive       | *                                                                                                        | Information about the disk drives installed on a computer, including their model, manufacturer, interface type, capacity                                                      |
| Win32_PhysicalMemory  | *                                                                                                        | Details about the physical memory modules in use, including their capacity, speed, manufacturer                                                                                |
| Win32_Product         | Caption, Description, Vendor, Version, InstallDate, InstallSource, PackageName                           | Information about installed software, including its name, description, vendor, version, installation date, installation source, and package name                                    |
| Win32_PnPEntity       | Caption, Description, DeviceID, Manufacturer, Name, PNPDeviceID, Service, Status                         | Details about Plug and Play devices, such as their name, description, device ID, manufacturer, name, PnP device ID, service, and status                                           |

### Windows command line

Qakbot create anonymous pipes to execute various built-in command-line tools processes, enabling it to retrieve information about the compromised system's environment effectively

[![](/assets/images/malware-analysis/qakbot/command_line_pipe.png)](/assets/images/malware-analysis/qakbot/command_line_pipe.png)
<center> <font size="3"><u>Figure</u>(15): %TEMP% <u>directory is used to store ephemeral temporary files.</u></font> </center>
<br>
here is the list of commands that can be used to gather information about the system:

| Windows Command                                | Output                                                |
|-----------------------------------------------|-------------------------------------------------------|
| ipconfig /all                                 | Displays detailed configuration information about all network interfaces. |
| whoami /all                                   | Displays user, group, and privileges information for the current user. |
| nltest /domain_trusts /all_trusts            | Lists all domain trusts established with the current domain. |
| qwinsta                                       | Lists information about all Remote Desktop sessions on the local system. |
| nslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%s | Performs a DNS lookup for LDAP service records for the specified domain controller. |
| net share                                     | Lists information about shared resources on the local system. |
| net localgroup                                | Lists information about local groups on the local system. |
| netstat -nao                                  | Lists active network connections and associated processes. |
| net view                                      | Lists information about shared resources on remote systems. |
| route print                                   | Displays the IP routing table for the local system. |
| arp -a                                        | Displays the ARP cache, which contains mappings of IP addresses to MAC addresses. |


### INFO from APIs

Additionally, it will use Windows API calls to get different system details like computer name, screen size, AD domain info, user name, processor details, whether it's a 32-bit or 64-bit Windows, and the operating system version, along with its respective full paths.

### Collect AntiViruses Information
Qakbot checks for specific antivirus programs like Kaspersky, Avast, and Norton ,etc to see if any antivirus software is active on the system. 
It does this by scanning running programs and looking for related processes from these vendors.

This list shows which antivirus vendors are associated with each process

| processes                                    | Related Vendor             |
|----------------------------------------------|----------------------------|
| ccSvcHst.exe;NortonSecurity.exe;nsWscSvc.exe | Norton Security            |
| avgcsrvx.exe;avgsvcx.exe;avgcsrva.exe        | AVG Antivirus              |
| MsMpEng.exe                                  | Microsoft Defender Antivirus |
| avp.exe;kavtray.exe                          | Kaspersky Antivirus        |
| coreServiceShell.exe;PccNTMon.exe;NTRTScan.exe | Trend Micro Antivirus    |
| fshoster32.exe                               | F-Secure Antivirus         |
| fmon.exe                                     | FortiClient Antivirus      |
| egui.exe;ekrn.exe                            | ESET                       |
| bdagent.exe;vsserv.exe;vsservppl.exe         | Bitdefender                |
| AvastSvc.exe;aswEngSrv.exe;aswToolsSvc.exe;afwServ.exe;aswidsagent.exe;AvastUI.exe | Avast |
| Sophos UI.exe;SophosUI.exe;SAVAdminService.exe;SavService.exe | Sophos       |
| WRSA.exe                                     | Webroot SecureAnywhere     |
| vkise.exe;isesrv.exe;cmdagent.exe            | Kaspersky                  |
| ByteFence.exe                                | ByteFence                  |
| MBAMService.exe;mbamgui.exe                  | Malwarebytes               |
| mcshield.exe                                 | McAfee                     |
| dwengine.exe;dwarkdaemon.exe;dwwatcher.exe   | Datawatch                  |
| SentinelServiceHost.exe;SentinelStaticEngine.exe;SentinelAgent.exe;... | SentinelOne |
| SonicWallClientProtectionService.exe;SWDash.exe | SonicWall                |
| CynetEPS.exe;CynetMS.exe;CynetConsole.exe    | Cynet                      |
| CSFalconService.exe;CSFalconContainer.exe   | CrowdStrike Falcon         |


# Executing C2 Commands

[![](/assets/images/malware-analysis/qakbot/c2_commands.png)](/assets/images/malware-analysis/qakbot/c2_commands.png)
<center><font size="3"><u>Figure</u>(11): <u>Conditional code flows depending on the 1st character of the C2 command.</u> </font></center>
<br>
After retrieving the C2 command and performing the appropriate decoding, the command is validated and then passed to the routing in which it will download and execute the malicious content. The malicious content will be downloaded using the URL at offset 3 from the beginning of the C2 string. Then, based on the first character of the C2 command, one of the switch case branches will be executed.

There are 5 available options or executions paths. Excluding the `n` command because it simply acts as a `NOP` operation, so we have 4 valid options.


### The 'b' Command

This execution branch will perform a process injection in a **newly** created `svchost.exe`process with `CREATE_SUSPENDED` flag. The injected malicious code is first checked to be a valid PE file -DLL or EXE- in order to be injected. For the new suspended `svchost.exe` process, the injection is done in a classic way using the APIs: `VirtualAllocEx` and `WriteProcessMemory`. What is more interesting here is the way the malware sets the new Entry point for the malicious code.

[![](/assets/images/malware-analysis/qakbot/change_OEP.png)](/assets/images/malware-analysis/qakbot/change_OEP.png)
<center> <font size="3"><u>Figure</u>(12): <u>A thread context is a snapshot of processor-specific register data.</u></font> </center>
<br>
It changes the value of the `EAX` register and sets the new thread context overwriting the old one. The `EAX` register in a newly created thread will always point to the **OEP**. This effectively transfers the entry point of the newly created `svchost.exe` process to the start of the injected malicious binary. 
## Process hollowing [injection]


QakBot selects a system process for process hollowing based on the machine's architecture (32-bit or 64-bit) and the installed antivirus software.

This list  includes the following system processes:
- %SystemRoot%\SysWOW64\OneDriveSetup.exe
- %SystemRoot%\System32\OneDriveSetup.exe
- %SystemRoot%\SysWOW64\msra.exe
- %SystemRoot%\System32\msra.exe
- %SystemRoot%\SysWOW64\xwizard.exe
- %SystemRoot%\System32\xwizard.exe
- %SystemRoot%\SysWOW64\mobsync.exe
- %SystemRoot%\System32\mobsync.exe
- %SystemRoot%\SysWOW64\AtBroker.exe
- %SystemRoot%\System32\AtBroker.exe
- %SystemRoot%\SysWOW64\wermgr.exe
- %SystemRoot%\System32\wermgr.exe
- %SystemRoot%\SysWOW64\explorer.exe 
- %SystemRoot%\explorer.exe .


It first calls the CreateProcessW() API with the CREATE_SUSPENDED flag to start a new process, making it to be suspended at the beginning.
[![](/assets/images/malware-analysis/qakbot/injection_1.png)](/assets/images/malware-analysis/qakbot/injection_1.png)
<center> <font size="3"><u>Figure</u>(12): <u>create a suspended process</u></font> </center>
<br>

Then it  allocates virtual memory in a target process, writes data into the allocated region, and then modifies the memory protection to allow execution . 

[![](/assets/images/malware-analysis/qakbot/injection_2.png)](/assets/images/malware-analysis/qakbot/injection_2.png)
<center> <font size="3"><u>Figure</u>(12): <u>create a suspended process</u></font> </center>
<br>

Next , it retrieve the context of the thread to modify it to set the instruction pointer (EIP/RIP register) to point to the entry point of the injected code . 

It finally calls the API ResumeThread() to resume the new processs . 










<br>
# Conclusion

qakbot is considered a straightforward loader but very efficient at the same time. So far, qakbot has targeted companies of all sizes and in a wide variety of industries and countries to deploy very serious malwares like **FickerStealer**, **Sendsafe**, and **Cobalt Strike** or even **Cuba Ransomware**. It's a must to take the appropriate countermeasures to defend your organization from such dreadful threat. We can't be sure which threat actors will also use qakbot as their loader in the future. Yet, one thing is sure: as effective as it has been to date, the threat posed by qakbot will not fade away in the coming future.


<br>
# IoCs

| No.  | Description             | Hash                                                         |
| :--- | ----------------------- | ------------------------------------------------------------ |
| 1    | The initial dropped DLL | EFBDD00DF327459C9DB2FFC79B2408F7F3C60E8BA5F8C5FFD0DEBAFF986863A8 |
| 2    | The unpacked DLL        | 5E74015E439AE6AA7E0A29F26EF2389663EB769D25ABCEB636D8272A74F27B7F |
| 4    | qakbot C&C Server 1   | http://intakinger.com/8/forum.php                            |
| 5    | qakbot C&C Server 2   | http://idgentexpliet.ru/8/forum.php                          |
| 6    | qakbot C&C Server 3   | http://declassivan.ru/8/forum.php                            |


<br>
# YARA Rule

```css
rule detect_qbot_v5
{
    meta:
        description = "just a rule for Qakbot v5"
        author = "Mohamed Ezzat (@ZW01f)"
        hash1  = "af6a9b7e7aefeb903c76417ed2b8399b73657440ad5f8b48a25cfe5e97ff868f"
        hash2  = "59559e97962e40a15adb2237c4d01cfead03623aff1725616caeaa5a8d273a35"
    strings:
        $s1 = "\\u%04X\\u%04X" ascii wide
        $s2 = "%u;%u;%u" ascii wide 
        $s3 = "CfGetPlatformInfo" ascii wide
        $p1 = {45 33 C0 E8 ?? ?? ?? ?? 35 91 CB 35 A2 41 3B C7}
        $p2 = { 0F B6 01 48 FF C1 44 33 C0 41 8B C0 41 C1 E8 04 83 E0 0F 44 33 04 82 41 8B C0 41 C1 E8 04 83 E0 0F 44 33 04 82 49 83 E9 01 75 ?? 41 F7 D041 8B C0 C3}
    condition:
        uint16(0) == 0x5A4D and all of ($p*) and (2 of ($s*)) and filesize < 500KB
} 
```

<br>
# Python Automated Configuration Extraction 

This python script is used to automatically extract the configuration of the qakbot malware. Steps required are as follows:

- Open the binary file.
- Get the .data section.
- Extract the the key and the encrypted configuration data at offset 16.
- SHA-1 hash the extracted key to get the final key.
- Use the key to decrypt the configurations.

```python
import pefile           #To manipulate PE files
import hashlib          #To perform the SHA-1 hashing
import binascii         #To perfrom unhexing
import arc4             #To perform the RC4 decryption

#This functions creates a PE object. Then iterates over the sections to locate
#the .data section in order to return its content
def Get_Date_Section(file):
    pe_file = pefile.PE(file)
    for section in pe_file.sections:
        if b".data" in section.Name:
            return section.get_data()

def rc4_decryption(key, encrypted_data):
    cipher = arc4.ARC4(key)
    decrypted_content = cipher.decrypt(encrypted_data)
    extracted_config = decrypted_content[:200]
    print(extracted_config.decode('utf-8')) #Prints in Unicode

def main():
    file_path = input("Pls enter the file path: ")
    data_section = Get_Date_Section(file_path)
    #The config data begins at offset 16 inside the .data section
    full_configuration = data_section[16:]

    #The key is the first 8 bytes while the encrypted data is the rest
    key = full_configuration[0:8]
    data = full_configuration[8:]

    #The RC4 key is only the first 5 bytes = 10 hex digits
    hashed_key = hashlib.sha1(key).hexdigest()
    rc4_key = hashed_key[0:10]

    rc4_decryption(binascii.unhexlify(rc4_key),data)


if __name__ == '__main__':
    main()
```


# Refrences

- [[QuickNote] Qakbot 5.0 – Decrypt strings and configuration](https://kienmanowar.wordpress.com/2024/04/24/quicknote-qakbot-5-0-decrypt-strings-and-configuration/)
- [https://labs.k7computing.com/index.php/qakbot-returns/](https://labs.k7computing.com/index.php/qakbot-returns/)